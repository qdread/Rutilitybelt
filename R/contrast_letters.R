#' Create comparison letters manually from a contrast object
#'
#' This function requires an object of class \code{emmGrid} containing contrasts
#' generated by the function \code{\link[emmeans]{contrast}}. Uses the internal function
#' \code{multcomp:::insert_absorb}.
#'
#' @param contrasts Object of class emmGrid generated by
#'   \code{\link[emmeans]{contrast}}.
#' @param levels_ordered Character vector of levels in the contrasts
#'    ordered ascending (or descending if you are using reverse contrasts).
#' @param scale Either 'additive' or 'multiplicative', default 'additive'.
#' @param bayes if \code{TRUE}, uses limits of 95% HPD of the contrast as a
#'   decision rule (overlapping zero if additive, one if multiplicative). If
#'   \code{FALSE}, uses the p-value of the contrasts.
#' @param alpha significance level. Default 0.95.
#'
#' @import tidyr
#' @import emmeans
#' @import multcomp
#' @export
contrast_letters <- function(contrasts, levels_ordered, scale = 'additive', bayes = TRUE, alpha = 0.95) {

  if (scale == 'additive') {
    sep <- ' - '
    cutoff <- 0
  } else {
    sep <- ' / '
    cutoff <- 1
  }

  message(paste0('Using', sep, 'as separator.'))
  message(ifelse(bayes, 'Using HPD limit as decision rule.', 'Using p-value as decision rule.'))

  comps <- as.data.frame(contrasts)
  comps <- tidyr::separate(comps, contrast, into = c('x', 'y'), sep = sep)
  comps_mat <- as.matrix(comps[, c('x', 'y')])

  if (bayes) {
    different <- with(comps, lower.HPD > cutoff | upper.HPD < cutoff)
  } else {
    different <- with(comps, p.value < (1 - alpha))
  }

  multcomp:::insert_absorb(different,
                           decreasing=FALSE,
                           comps = comps_mat,
                           lvl_order = levels_ordered)
}

#' Utility function to readjust alpha for doing Sidak corrections within each CLD by group
#' @export
readjusted_alpha <- function(true_alpha, treatments_total, treatments_per_group) {
  m1 <- choose(prod(treatments_total), 2)
  m2 <- choose(prod(treatments_per_group), 2)
  alpha_sidak <- 1 - (1 - true_alpha)^(1/m1)
  1 - (1 - alpha_sidak)^m2
}
