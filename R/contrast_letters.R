#' Create comparison letters manually from a contrast object
#'
#' This function requires an object of class \code{emmGrid} containing contrasts
#' generated by the function \code{\link[emmeans]{contrast}}. Uses the internal function
#' \code{multcomp:::insert_absorb}.
#'
#' @param contrasts Object of class emmGrid generated by
#'   \code{\link[emmeans]{contrast}}.
#' @param levels_ordered Character vector of levels in the contrasts
#'    ordered ascending (or descending if you are using reverse contrasts).
#' @param scale Either 'additive' or 'multiplicative', default 'additive'.
#' @param bayes if \code{TRUE}, uses limits of 95% HPD of the contrast as a
#'   decision rule (overlapping zero if additive, one if multiplicative). If
#'   \code{FALSE}, uses the p-value of the contrasts.
#' @param alpha significance level. Default 0.95.
#'
#' @import tidyr
#' @import emmeans
#' @import multcomp
#' @export
contrast_letters <- function(contrasts, levels_ordered, scale = 'additive', bayes = TRUE, alpha = 0.95) {

  if (scale == 'additive') {
    sep <- ' - '
    cutoff <- 0
  } else {
    sep <- ' / '
    cutoff <- 1
  }

  message(paste0('Using', sep, 'as separator.'))
  message(ifelse(bayes, 'Using HPD limit as decision rule.', 'Using p-value as decision rule.'))

  comps <- as.data.frame(contrasts)
  comps <- tidyr::separate(comps, contrast, into = c('x', 'y'), sep = sep)
  comps_mat <- as.matrix(comps[, c('x', 'y')])

  if (bayes) {
    different <- with(comps, lower.HPD > cutoff | upper.HPD < cutoff)
  } else {
    different <- with(comps, p.value < (1 - alpha))
  }

  multcomp:::insert_absorb(different,
                           decreasing=FALSE,
                           comps = comps_mat,
                           lvl_order = levels_ordered)
}

#' Bayesian multiple comparison letters from posterior summary
#' 
#' Uses output from \code{bayestestR::describe_posterior()} run on \code{emmeans} objects. Based on the Bayesian p-value analog.
#' 
#' @param post_cons Data frame of contrasts, usually an object of class describe_posterior
#' @param post_means Data frame of means, used for correctly ordering the contrasts, usually an object of class describe_posterior
#' @param group_col Name of column, the levels of which are being compared
#' @param contrast_col Name of column with the pairwise contrast names, default is \code{"contrast"}
#' @param mean_col Name of column with the means in post_means, default is \code{"emmean"}
#' @param pvalue_col Name of column with the Bayesian p-value analog, default is \code{"p_MAP"}
#' @param contrast_sep Separator of the two levels in the contrast column, default is \code{" - "}
#' @param alpha Significance cutoff, defaults to 0.05 for no good reason
#' @param decreasing_letters Defaults to FALSE so that "a" is the lowest mean. If TRUE, "a" is the highest mean.
#' 
#' @import multcomp
#' @export
bayes_multcompletters <- function(post_cons, post_means, group_col, contrast_col = 'contrast', mean_col = 'emmean', pvalue_col = 'p_MAP', contrast_sep = ' - ', alpha = 0.05, decreasing_letters = FALSE) {
  different <- with(post_cons, setNames(get(pvalue_col) < alpha, get(contrast_col)))
  levels_ordered <- as.character(post_means[[group_col]][order(post_means[[mean_col]])])
  
  letter_vec <- multcomp:::insert_absorb(different,
                                         decreasing = decreasing_letters,
                                         separator = contrast_sep,
                                         lvl_order = levels_ordered)
  data.frame(group = names(letter_vec$Letters), letter = letter_vec$Letters) |> setNames(c(group_col, 'letter'))
  
}


#' Utility function to readjust alpha for doing Sidak corrections within each CLD by group
#' @export
readjusted_alpha <- function(true_alpha, treatments_total, treatments_per_group) {
  m1 <- choose(prod(treatments_total), 2)
  m2 <- choose(prod(treatments_per_group), 2)
  alpha_sidak <- 1 - (1 - true_alpha)^(1/m1)
  1 - (1 - alpha_sidak)^m2
}

#' Additional improved comparison letter function based on tidyverse
#' @export
get_comp_letters <- function(post_means,
                             post_cons,
                             diff_byvars = c(),
                             diff_levelvar,
                             x_var,
                             pvalue_var,
                             contrast_var = 'contrast',
                             contrast_sep = ' - ',
                             p_thresh = 0.05,
                             decreasing_letters = FALSE) {
  # Group the means and contrasts into lists based on the provided grouping variables
  # If no grouping variables are provided, create a single one.
  if (length(diff_byvars) == 0) {
    post_means <- mutate(post_means, .byvar = 'x')
    post_cons <- mutate(post_cons, .byvar = 'x')
    diff_byvars <- '.byvar'
  }
  
  comp_data <- left_join(
    post_means %>% mutate(group = apply(.[, diff_levelvar, drop = FALSE], 1, paste, collapse = ' ')) %>% group_by(across(all_of(diff_byvars))) %>% nest(.key = 'means'),
    post_cons %>% group_by(across(all_of(diff_byvars))) %>% nest(.key = 'cons'),
    by = diff_byvars
  )
  
  # Get level order and split the contrast names up into group1 and group2 columns
  comp_data <- comp_data %>%
    mutate(
      level_order = map(means, ~ .$group[order(.[[x_var]])]),
      cons = map(cons, function(cs)
        mutate(
          cs,
          grp1 = map_chr(strsplit(
            as.character(!!sym(contrast_var)), contrast_sep
          ), 1),
          grp2 = map_chr(strsplit(
            as.character(!!sym(contrast_var)), contrast_sep
          ), 2)
        ))
    )
  
  # Define function to get square comparison matrix, ordered in increasing order of the letters
  ordered_comp_matrix <- function(con_df, lvl_order, pvalue_var) {
    lvl_pairs <- combn(lvl_order, m = 2, simplify = FALSE)
    m <- matrix(
      0,
      nrow = length(lvl_order),
      ncol = length(lvl_order),
      dimnames = list(lvl_order, lvl_order)
    )
    for (p in lvl_pairs) {
      idx <- which((con_df$grp1 == p[1] &
                      con_df$grp2 == p[2]) |
                     (con_df$grp2 == p[1] &
                        con_df$grp1 == p[2])
      )
      m[p[1], p[2]] <- con_df[[pvalue_var]][idx]
      m[p[2], p[1]] <- con_df[[pvalue_var]][idx]
    }
    return(m)
  }
  
  # Create the square symmetric matrix for each comparison and apply multcompLetters to it
  comp_data <- comp_data %>%
    mutate(
      comp_mat = map2(
        cons,
        level_order,
        ~ ordered_comp_matrix(.x, .y, pvalue_var = pvalue_var)
      ),
      letters = map(
        comp_mat,
        ~ multcompView::multcompLetters(., threshold = p_thresh, reversed = decreasing_letters)$Letters
      )
    )
  
  # Create output data frame with letter column
  comp_data %>%
    dplyr::select(-c(means, cons, level_order, comp_mat)) %>%
    mutate(letters = map(letters, ~ tibble(
      group = names(.), letter = .
    ))) %>%
    unnest(letters) %>%
    ungroup %>%
    dplyr::select(-any_of('.byvar')) %>%
    rename(!!sym(diff_levelvar) := group)
}



